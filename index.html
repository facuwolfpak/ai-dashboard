<!--
AI Action Dashboard ‚Äî Facundo starter kit
=================================================
What you get (MVP):
1) A single‚Äëpage dashboard you can host on GitHub Pages (static).
2) Upload .txt/.md/.docx/.pdf meeting notes (txt/md best). The app will:
   ‚Ä¢ Extract action items (owner, due date, distributor/customer, status) with a built‚Äëin heuristic parser (no API needed),
     OR (recommended) send notes to your own serverless AI endpoint for higher accuracy.
3) Ask natural‚Äëlanguage questions like: "What distributors have pending items?" and get an answer + filtered table.
4) Local persistence via browser localStorage (MVP). Swap to Supabase/Firebase later without rewriting UI.

How to deploy in 5 minutes (MVP / no backend):
- Create a new GitHub repo ‚Üí add this file as index.html ‚Üí enable GitHub Pages ‚Üí done.
- You can use heuristic parsing immediately (toggle in Settings panel).

How to enable AI (serverless, keeps your API key safe):
- If you use Vercel: create /api/ingest.js and /api/query.js from the snippets at the end. Set env var OPENAI_API_KEY (or Anthropic, etc.).
- In the dashboard Settings, set "Backend Mode" to "Serverless AI" and paste your API base URLs (e.g. /api/ingest and /api/query).

Note: This single file contains the full frontend. Scroll to the bottom for serverless function code (Node.js, Vercel). You can copy those into /api.
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AI Action Dashboard</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root { --bg: #0b0f14; --card:#0e1621; --muted:#9fb0c3; --accent:#60a5fa; }
    html, body { height: 100%; background: linear-gradient(180deg, #0b0f14 0%, #0e1621 100%); color: #e6edf3; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .card { background: rgba(14,22,33,0.85); border: 1px solid rgba(255,255,255,0.06); box-shadow: 0 10px 30px rgba(0,0,0,0.35); border-radius: 18px; }
    .btn { transition: all .15s ease; }
    .btn:hover { transform: translateY(-1px); }
    .pill { border: 1px solid rgba(255,255,255,.08); border-radius: 999px; padding: 4px 10px; font-size: 12px; }
    .kbd { border: 1px solid rgba(255,255,255,.18); padding: 2px 6px; border-radius: 6px; background: rgba(255,255,255,.04); font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 12px; }
    .grid-fit { display:grid; grid-template-columns:repeat(auto-fit,minmax(280px,1fr)); gap:16px; }
    .tw-input { background:#0a1320; border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:10px 12px; outline:none; width:100%; }
    .tw-input:focus { border-color: var(--accent); box-shadow: 0 0 0 4px rgba(96,165,250,.15); }
    .tw-select { background:#0a1320; border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:10px 12px; outline:none; width:100%; color:#e6edf3; }
    .badge { font-size:12px; padding:4px 8px; border-radius:999px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.1); }
    .status-open { background:#33241f; border-color:#7a3c2a; color:#ffb088; }
    .status-done { background:#1d3326; border-color:#315b3f; color:#9be2b2; }
    .status-hold { background:#2a2835; border-color:#49415a; color:#c9b3ff; }
    .link { color:#93c5fd; text-decoration: underline; text-underline-offset: 3px; }
      .dropzone { border:1.5px dashed rgba(255,255,255,.25); border-radius:14px; padding:14px; background: rgba(255,255,255,.03); text-align:center; }
    .dropzone.dragover { border-color: var(--accent); background: rgba(96,165,250,.08); }
    .rec-dot { width:10px; height:10px; border-radius:999px; background:#ef4444; display:inline-block; margin-right:6px; box-shadow:0 0 0 0 rgba(239,68,68,.7); animation:pulse 1s infinite; }
    @keyframes pulse { 0%{box-shadow:0 0 0 0 rgba(239,68,68,.6)} 70%{box-shadow:0 0 0 10px rgba(239,68,68,0)} 100%{box-shadow:0 0 0 0 rgba(239,68,68,0)} }
  </style>
</head>
<body class="min-h-screen">
  <header class="max-w-7xl mx-auto px-5 pt-8 pb-4">
    <div class="flex items-center justify-between">
      <div class="flex items-center gap-3">
        <div class="w-10 h-10 rounded-2xl bg-gradient-to-br from-blue-400 to-cyan-400"></div>
        <div>
          <h1 class="text-2xl font-semibold">AI Action Dashboard</h1>
          <p class="text-sm text-slate-400">Upload notes ‚Üí extract action items ‚Üí ask questions like ‚ÄúWhich distributors have pending items?‚Äù</p>
        </div>
      </div>
      <div class="flex items-center gap-2">
        <button id="btn-export" class="btn pill">Export JSON</button>
        <button id="btn-import" class="btn pill">Import JSON</button>
        <input id="import-file" type="file" accept="application/json" class="hidden"/>
      </div>
    </div>
  </header>

  <main class="max-w-7xl mx-auto px-5 pb-24">
    <div class="grid lg:grid-cols-3 gap-6">
      <!-- Left column: Ingest & Ask -->
      <section class="lg:col-span-1 card p-5">
        <h2 class="text-lg font-semibold mb-3">Ingest notes</h2>
        <div class="space-y-3">
          <input id="title" class="tw-input" placeholder="Meeting title (e.g., PriceSmart 2025 planning)"/>
          <textarea id="notes" class="tw-input" rows="10" placeholder="Paste your notes here (txt/markdown best). Use lines like: 
- [ ] Action: Send spec sheet to Eatics (owner: Facu, due: 2025-10-07, distributor: Eatics, status: open)"></textarea>
          <div class="flex items-center gap-2">
            <button id="btn-mic" type="button" class="btn rounded-xl px-3 py-2 bg-rose-500/20 hover:bg-rose-500/30">üéôÔ∏è Dictate</button>
            <span id="mic-status" class="text-xs text-slate-400">Mic: idle</span>
            <select id="mic-lang" class="tw-select w-44 ml-auto">
              <option value="en-US">English (US)</option>
              <option value="es-ES">Espa√±ol (ES)</option>
              <option value="es-MX">Espa√±ol (MX)</option>
              <option value="pt-BR">Portugu√™s (BR)</option>
            </select>
          </div>
          <div id="dropzone" class="dropzone text-sm text-slate-400">Drop .txt / .md files here (PDF/DOCX text extraction varies by browser). Click "Upload file" for manual.</div>
          <div class="grid-fit">
            <div>
              <label class="text-xs text-slate-400">Parsing mode</label>
              <select id="mode" class="tw-select">
                <option value="heuristic">Heuristic (no AI)</option>
                <option value="serverless">Serverless AI (recommended)</option>
              </select>
            </div>
            <div id="serverless-settings" class="hidden">
              <label class="text-xs text-slate-400">Serverless endpoints</label>
              <input id="ingest-url" class="tw-input mt-1" placeholder="/api/ingest"/>
              <input id="query-url" class="tw-input mt-2" placeholder="/api/query"/>
            </div>
          </div>
          <div class="flex gap-2 flex-wrap">
            <button id="btn-ingest" class="btn bg-blue-500 hover:bg-blue-600 text-white rounded-xl px-4 py-2">Save &amp; Extract (Ctrl+Enter)</button>
            <button id="btn-file" type="button" class="btn bg-slate-700 hover:bg-slate-600 rounded-xl px-4 py-2">Choose File</button>
            <input id="file-input" type="file" accept=".txt,.md,.pdf,.docx" class="hidden"/>
          </div>
          <p id="ingest-status" class="text-sm text-slate-400"></p>
        </div>

        <hr class="my-6 border-slate-800"/>

        <h2 class="text-lg font-semibold mb-3">Ask your data</h2>
        <input id="question" class="tw-input" placeholder="e.g., What distributors have pending items?"/>
        <button id="btn-ask" class="btn w-full mt-2 bg-violet-500 hover:bg-violet-600 text-white rounded-xl px-4 py-2">Ask</button>
        <p class="text-xs text-slate-400 mt-2">Tip: press <span class="kbd">/</span> to focus the question box</p>
        <div id="answer" class="mt-4 text-slate-200"></div>
      </section>

      <!-- Right column: Table -->
      <section class="lg:col-span-2 card p-5">
        <div class="flex items-center justify-between">
          <h2 class="text-lg font-semibold">Action items</h2>
          <div class="flex gap-2">
            <select id="filter-status" class="tw-select w-40">
              <option value="">Status: All</option>
              <option value="open">Open</option>
              <option value="hold">On Hold</option>
              <option value="done">Done</option>
            </select>
            <input id="filter-distributor" class="tw-input w-56" placeholder="Filter by distributor"/>
          </div>
        </div>
        <div class="mt-4 overflow-x-auto">
          <table class="w-full text-sm">
            <thead class="text-slate-400">
              <tr class="text-left border-b border-slate-800">
                <th class="py-2 pr-3">Distributor</th>
                <th class="py-2 pr-3">Action</th>
                <th class="py-2 pr-3">Owner</th>
                <th class="py-2 pr-3">Due</th>
                <th class="py-2 pr-3">Status</th>
                <th class="py-2 pr-3">Source</th>
              </tr>
            </thead>
            <tbody id="rows"></tbody>
          </table>
        </div>
      </section>
    </div>
  </main>

  <template id="row-tpl">
    <tr class="border-b border-slate-800/60">
      <td class="py-2 pr-3 font-medium"></td>
      <td class="py-2 pr-3"></td>
      <td class="py-2 pr-3"></td>
      <td class="py-2 pr-3"></td>
      <td class="py-2 pr-3"><span class="badge"></span></td>
      <td class="py-2 pr-3 text-slate-400"></td>
    </tr>
  </template>

  <script>
    // --------- State ---------
    const state = {
      items: JSON.parse(localStorage.getItem('ai_action_items') || '[]'),
      mode: 'heuristic',
      ingestUrl: '/api/ingest',
      queryUrl: '/api/query',
      recording: false,
      recognizer: null
    };

    // --------- Helpers ---------
    const el = id => document.getElementById(id);
    const fmtDate = s => s ? new Date(s).toISOString().slice(0,10) : '';
    const save = () => localStorage.setItem('ai_action_items', JSON.stringify(state.items));

    // Simple heuristic extraction: looks for checklist/task patterns
    function heuristicExtract(text, meta={}) {
      const lines = text.split(/\n+/);
      const results = [];
      const taskRe = /(?:\-|\*|\d+\.)?\s*(?:\[([ xX])\]\s*)?(?:Action:)?\s*(.+?)(?:\s*\(([^\)]*)\))?$/i;
      const kvRe = /(owner|due|distributor|status)\s*:\s*([^,;\)]+)\s*/ig;
      for (const raw of lines) {
        const line = raw.trim();
        if (!line) continue;
        const m = line.match(taskRe);
        if (!m) continue;
        let desc = m[2]?.trim() || '';
        if (!desc) continue;
        const item = { id: crypto.randomUUID(), description: desc, owner:'', due:'', distributor:'', status:'open', source: meta.title||'Untitled' };
        const metaStr = m[3]||'';
        let mm; while((mm = kvRe.exec(metaStr))){
          const k = mm[1].toLowerCase(); const v = mm[2].trim();
          if (k==='due') { const d = new Date(v); if(!isNaN(d)) item.due = d.toISOString(); }
          else item[k] = v;
        }
        // If checkbox was [x], mark done
        if (m[1] && m[1].toLowerCase()==='x') item.status = 'done';
        results.push(item);
      }
      return results;
    }

    function render(items = state.items) {
      const tbody = el('rows');
      tbody.innerHTML = '';
      const tpl = el('row-tpl');
      const statusFilter = el('filter-status').value;
      const distFilter = el('filter-distributor').value.trim().toLowerCase();
      const filtered = items.filter(it =>
        (!statusFilter || it.status === statusFilter) &&
        (!distFilter || (it.distributor||'').toLowerCase().includes(distFilter))
      );
      for (const it of filtered) {
        const row = tpl.content.firstElementChild.cloneNode(true);
        row.children[0].textContent = it.distributor || '‚Äî';
        row.children[1].textContent = it.description;
        row.children[2].textContent = it.owner || '‚Äî';
        row.children[3].textContent = fmtDate(it.due);
        const badge = row.children[4].firstElementChild;
        badge.textContent = it.status || 'open';
        badge.classList.add(
          it.status==='done' ? 'status-done' : it.status==='hold' ? 'status-hold' : 'status-open'
        );
        row.children[5].textContent = it.source || '';
        tbody.appendChild(row);
      }
    }

    function setModeUI() {
      const mode = el('mode').value;
      state.mode = mode;
      el('serverless-settings').classList.toggle('hidden', mode !== 'serverless');
    }

    // --------- Mic (Web Speech API) ---------
    function setupMic(){
      const status = el('mic-status');
      const btn = el('btn-mic');
      if (!window.isSecureContext) {
        status.textContent = 'Mic: requires HTTPS (GitHub Pages is OK)';
        btn.disabled = true; return;
      }
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) { status.textContent = 'Mic: not supported in this browser'; btn.disabled = true; return; }
      state.recognizer = new SR();
      state.recognizer.continuous = true;
      state.recognizer.interimResults = true;
      state.recognizer.onstart = ()=>{ status.innerHTML = '<span class="rec-dot"></span>Listening‚Ä¶'; btn.textContent = '‚èπ Stop'; };
      state.recognizer.onerror = (e)=>{ status.textContent = 'Mic error: ' + (e.error||'unknown'); };
      state.recognizer.onresult = (ev)=>{
        let finalChunk = '';
        for (let i = ev.resultIndex; i < ev.results.length; i++) {
          const r = ev.results[i];
          if (r.isFinal) finalChunk += r[0].transcript + '\n';
        }
        if (finalChunk) el('notes').value += (el('notes').value ? '\n' : '') + finalChunk.trim();
      };
      state.recognizer.onend = ()=>{
        if (state.recording) {
          try { state.recognizer.start(); } catch {}
        } else {
          status.textContent = 'Mic: stopped'; btn.textContent = 'üéôÔ∏è Dictate';
        }
      };
    }
      state.recognizer = new SR();
      state.recognizer.continuous = true; state.recognizer.interimResults = true;
      state.recognizer.onresult = (ev)=>{
        let finalChunk = '';
        for (let i = ev.resultIndex; i < ev.results.length; i++) {
          const r = ev.results[i];
          const t = r[0].transcript;
          if (r.isFinal) finalChunk += t + '
';
        }
        if (finalChunk) el('notes').value += (el('notes').value ? '
' : '') + finalChunk.trim();
      };
      state.recognizer.onend = ()=>{ if(state.recording){ // auto-restart for long dictations
        try { state.recognizer.start(); } catch {}
      } };
    }
    function toggleMic(){
      if (!state.recognizer) return;
      if (!state.recording){
        try {
          state.recognizer.lang = el('mic-lang').value || 'en-US';
          state.recording = true;
          state.recognizer.start();
        } catch(e){ el('mic-status').textContent = 'Mic error: '+e.message; }
      } else {
        try {
          state.recording = false;
          state.recognizer.stop();
        } catch(e){ el('mic-status').textContent = 'Mic error: '+e.message; }
      }
    }
        catch(e){ el('mic-status').textContent = 'Mic error: '+e.message; }
      } else {
        try { state.recording = false; state.recognizer.stop(); el('mic-status').textContent = 'Mic: stopped'; el('btn-mic').textContent = 'üéôÔ∏è Dictate'; }
        catch(e){ el('mic-status').textContent = 'Mic error: '+e.message; }
      }
    }

    // --------- Drag & Drop ---------
    function setupDrop(){
      const dz = el('dropzone');
      if (!dz) return;
      ;['dragenter','dragover'].forEach(ev=> dz.addEventListener(ev, (e)=>{ e.preventDefault(); e.stopPropagation(); dz.classList.add('dragover'); }));
      ;['dragleave','drop'].forEach(ev=> dz.addEventListener(ev, (e)=>{ e.preventDefault(); e.stopPropagation(); dz.classList.remove('dragover'); }));
      dz.addEventListener('drop', async (e)=>{
        const files = [...(e.dataTransfer?.files || [])];
        if (!files.length) return;
        let combined = '';
        for (const f of files){
          try {
            if (/\.(txt|md)$/i.test(f.name)) {
              combined += `

# ${f.name}
` + await f.text();
            } else {
              combined += `

# ${f.name}
(Preview not supported here ‚Äî use the Upload button for better extraction)`;
            }
          } catch {}
        }
        if (combined.trim()) el('notes').value = (el('notes').value ? el('notes').value+'
' : '') + combined.trim();
      });
    }

    // --------- Events ---------
    el('mode').addEventListener('change', setModeUI);
    el('btn-mic').addEventListener('click', toggleMic);
    el('btn-file').addEventListener('click', ()=> el('file-input').click());
    // Ctrl/Cmd+Enter to Save & Extract
    el('notes').addEventListener('keydown', (e)=>{ if ((e.ctrlKey||e.metaKey) && e.key==='Enter'){ e.preventDefault(); el('btn-ingest').click(); }});
    el('btn-mic').addEventListener('click', toggleMic);

    el('btn-ingest').addEventListener('click', async () => {
      const title = el('title').value.trim();
      const text = el('notes').value.trim();
      if (!text) { el('ingest-status').textContent = 'Paste some notes first.'; return; }

      el('ingest-status').textContent = 'Parsing‚Ä¶';

      let newItems = [];
      try {
        if (state.mode === 'heuristic') {
          newItems = heuristicExtract(text, { title });
        } else {
          const ingestUrl = (el('ingest-url').value || state.ingestUrl).trim();
          const r = await fetch(ingestUrl, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ title, text }) });
          if (!r.ok) throw new Error('Serverless ingest failed');
          const data = await r.json();
          newItems = data.items || [];
        }
        state.items = [...newItems, ...state.items];
        save();
        render();
        el('ingest-status').textContent = `Added ${newItems.length} action(s).`;
        el('notes').value=''; el('title').value='';
      } catch (e) {
        console.error(e);
        el('ingest-status').textContent = 'Error: ' + e.message;
      }
    });

    el('file-input').addEventListener('change', async (e) => {
      const file = e.target.files[0]; if (!file) return;
      const text = await file.text();
      el('notes').value = text;
      el('title').value = file.name.replace(/\.[^.]+$/,'');
    });

    el('filter-status').addEventListener('change', () => render());
    el('filter-distributor').addEventListener('input', () => render());

    document.addEventListener('keydown', (e)=>{ if(e.key==='/' && document.activeElement.tagName!=='INPUT' && document.activeElement.tagName!=='TEXTAREA'){ e.preventDefault(); el('question').focus(); }});

    el('btn-ask').addEventListener('click', async () => {
      const q = el('question').value.trim(); if (!q) return;
      // Quick built-in intent: common question from Facu
      if (/pending items|pendientes/i.test(q)) {
        const pending = state.items.filter(it => (it.status||'open').toLowerCase()==='open');
        const byDist = {};
        for (const it of pending) {
          const d = (it.distributor||'Unassigned').trim();
          byDist[d] = (byDist[d]||0)+1;
        }
        const summary = Object.entries(byDist).sort((a,b)=>b[1]-a[1]).map(([d,n])=>`‚Ä¢ ${d}: ${n} open`).join('<br>');
        el('answer').innerHTML = summary || 'No pending items.';
        el('filter-status').value = 'open'; render();
        return;
      }

      if (state.mode === 'serverless') {
        const queryUrl = (el('query-url').value || state.queryUrl).trim();
        try {
          const r = await fetch(queryUrl, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ question: q, items: state.items })});
          const data = await r.json();
          el('answer').innerText = data.answer || 'No answer.';
        } catch (e) {
          el('answer').innerText = 'Query error: ' + e.message;
        }
      } else {
        // Simple client-side filter as fallback
        const words = q.toLowerCase().split(/\s+/).filter(Boolean);
        const matches = state.items.filter(it => words.every(w => JSON.stringify(it).toLowerCase().includes(w)));
        el('answer').innerHTML = `Found ${matches.length} matching item(s).`; 
        render(matches);
      }
    });

    el('btn-export').addEventListener('click', () => {
      const blob = new Blob([JSON.stringify(state.items, null, 2)], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download='ai_action_items.json'; a.click(); URL.revokeObjectURL(url);
    });

    el('btn-import').addEventListener('click', ()=> el('import-file').click());
    el('import-file').addEventListener('change', async (e)=>{
      const f = e.target.files[0]; if (!f) return;
      const txt = await f.text();
      try { const arr = JSON.parse(txt); if (Array.isArray(arr)) { state.items = arr; save(); render(); } }
      catch {}
    });

    // Initial
    setModeUI();
    setupMic();
    setupDrop();
    render();
  </script>

  <!-- ======================= SERVERLESS (copy into /api on Vercel) =======================
  File: /api/ingest.js  ‚Äî Extract structured actions from freeform notes using OpenAI
  ----------------------------------------------------------------------------------- -->
  <!--
  export default async function handler(req, res) {
    try {
      if (req.method !== 'POST') return res.status(405).json({ error: 'Method not allowed' });
      const { title = 'Untitled', text = '' } = req.body || {};
      if (!process.env.OPENAI_API_KEY) return res.status(500).json({ error: 'Missing OPENAI_API_KEY' });

      const prompt = `You are an operations analyst for a CPG export broker (Califia Farms, Level-Up Premium Foods, WolfPak). Extract action items as JSON array with fields: id (uuid), description, owner, due (ISO8601 or empty), distributor, status in {open, hold, done}, source. Be concise.\n\nTitle: ${title}\nNotes:\n${text}`;

      const r = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${process.env.OPENAI_API_KEY}` },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages: [
            { role: 'system', content: 'You extract structured tasks for a sales/export pipeline.' },
            { role: 'user', content: prompt }
          ],
          response_format: { type: 'json_object' },
          temperature: 0.2
        })
      });
      const data = await r.json();
      // Expect { items: [...] }
      let items = [];
      try { const obj = JSON.parse(data.choices?.[0]?.message?.content || '{}'); items = obj.items || obj || []; } catch {}
      // If model returned array directly
      if (Array.isArray(items)) items = items; else if (Array.isArray(obj)) items = obj; 
      // Ensure shape
      items = (items || []).map(it => ({
        id: it.id || crypto.randomUUID?.() || Math.random().toString(36).slice(2),
        description: it.description || '', owner: it.owner || '', due: it.due || '',
        distributor: it.distributor || '', status: (it.status||'open').toLowerCase(), source: title
      }));
      return res.status(200).json({ items });
    } catch (e) {
      console.error(e);
      return res.status(500).json({ error: e.message });
    }
  }
  -->

  <!--
  File: /api/query.js ‚Äî Natural language Q&A over current items
  ------------------------------------------------------------ -->
  <!--
  export default async function handler(req, res) {
    try {
      if (req.method !== 'POST') return res.status(405).json({ error: 'Method not allowed' });
      const { question = '', items = [] } = req.body || {};
      if (!process.env.OPENAI_API_KEY) return res.status(500).json({ error: 'Missing OPENAI_API_KEY' });

      const sys = `You answer succinctly as a commercial ops assistant for an export broker. If the user asks for "distributors with pending items", list distributors with count of tasks where status = open. If dates are asked, use due. Reply in the same language as the question.`;
      const content = `DATA = ${JSON.stringify(items).slice(0, 120_000)}\n\nQUESTION = ${question}`;

      const r = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${process.env.OPENAI_API_KEY}` },
        body: JSON.stringify({ model: 'gpt-4o-mini', messages: [ { role:'system', content: sys }, { role:'user', content } ], temperature: 0.1 })
      });
      const data = await r.json();
      const answer = data.choices?.[0]?.message?.content?.trim() || 'No answer.';
      return res.status(200).json({ answer });
    } catch (e) {
      console.error(e); return res.status(500).json({ error: e.message });
    }
  }
  -->

  <!--
  Notes:
  - Swap OpenAI for Anthropic (Claude) or Azure OpenAI by changing the fetch URL and payload shape.
  - Persist items centrally by replacing localStorage with Supabase: create a table actions(id, description, owner, due, distributor, status, source, created_at) and replace save()/load() with RPC.
  - To ingest recordings/transcripts automatically, post them to /api/ingest after your meetings and they will appear on refresh.
  - Security: never expose API keys in the frontend. Use serverless functions.
  - File parsing: for PDF/DOCX you‚Äôll get best results if you convert to text before uploading, but many browsers will still return partial text.
  -->
</body>
</html>
